/*
 * Pelion Device Management API
 * Pelion Device Management API build from the publicly defined API definitions.
 *
 * OpenAPI spec version: 3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.arm.mbed.cloud.sdk.lowlevel.pelionclouddevicemanagement.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.io.Serializable;

/**
 * WebsocketChannel
 */

public class WebsocketChannel implements Serializable {
    private static final long serialVersionUID = 1L;

    @SerializedName("queue_size")
    private Integer queueSize = null;

    @SerializedName("serialization")
    private SerializationConfigData serialization = null;

    /**
     * Channel status is &#39;connected&#39; when the channel has an active WebSocket bound to it. The status is
     * &#39;disconnected&#39; when either the channel or the WebSocket bound to it is closed and &#39;unknown&#39; when
     * the server cannot determine it.
     */
    @JsonAdapter(StatusEnum.Adapter.class)
    public enum StatusEnum {
        CONNECTED("connected"),

        DISCONNECTED("disconnected"),

        UNKNOWN("unknown");

        private String value;

        StatusEnum(String value) {
            this.value = value;
        }

        public String getValue() {
            return value;
        }

        @Override
        public String toString() {
            return String.valueOf(value);
        }

        public static StatusEnum fromValue(String text) {
            for (StatusEnum b : StatusEnum.values()) {
                if (String.valueOf(b.value).equals(text)) {
                    return b;
                }
            }
            return null;
        }

        public static class Adapter extends TypeAdapter<StatusEnum> {
            @Override
            public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
                jsonWriter.value(enumeration.getValue());
            }

            @Override
            public StatusEnum read(final JsonReader jsonReader) throws IOException {
                String value = jsonReader.nextString();
                return StatusEnum.fromValue(String.valueOf(value));
            }
        }
    }

    @SerializedName("status")
    private StatusEnum status = StatusEnum.DISCONNECTED;

    public WebsocketChannel queueSize(Integer queueSize) {
        this.queueSize = queueSize;
        return this;
    }

    /**
     * Number of events in the channel&#39;s event queue waiting to be delivered. If the server cannot determine the
     * queue size the value will be set to &#x60;-1&#x60;.
     * 
     * @return queueSize
     **/
    @ApiModelProperty(example = "0",
                      value = "Number of events in the channel's event queue waiting to be delivered. If the server cannot determine the queue size the value will be set to `-1`.")
    public Integer getQueueSize() {
        return queueSize;
    }

    public void setQueueSize(Integer queueSize) {
        this.queueSize = queueSize;
    }

    public WebsocketChannel serialization(SerializationConfigData serialization) {
        this.serialization = serialization;
        return this;
    }

    /**
     * Get serialization
     * 
     * @return serialization
     **/
    @ApiModelProperty(value = "")
    public SerializationConfigData getSerialization() {
        return serialization;
    }

    public void setSerialization(SerializationConfigData serialization) {
        this.serialization = serialization;
    }

    public WebsocketChannel status(StatusEnum status) {
        this.status = status;
        return this;
    }

    /**
     * Channel status is &#39;connected&#39; when the channel has an active WebSocket bound to it. The status is
     * &#39;disconnected&#39; when either the channel or the WebSocket bound to it is closed and &#39;unknown&#39; when
     * the server cannot determine it.
     * 
     * @return status
     **/
    @ApiModelProperty(example = "disconnected",
                      value = "Channel status is 'connected' when the channel has an active WebSocket bound to it. The status is 'disconnected' when either the channel or the WebSocket bound to it is closed and 'unknown' when the server cannot determine it.")
    public StatusEnum getStatus() {
        return status;
    }

    public void setStatus(StatusEnum status) {
        this.status = status;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        WebsocketChannel websocketChannel = (WebsocketChannel) o;
        return Objects.equals(this.queueSize, websocketChannel.queueSize)
               && Objects.equals(this.serialization, websocketChannel.serialization)
               && Objects.equals(this.status, websocketChannel.status);
    }

    @Override
    public int hashCode() {
        return Objects.hash(queueSize, serialization, status);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("class WebsocketChannel {\n");

        sb.append("    queueSize: ").append(toIndentedString(queueSize)).append("\n");
        sb.append("    serialization: ").append(toIndentedString(serialization)).append("\n");
        sb.append("    status: ").append(toIndentedString(status)).append("\n");
        sb.append("}");
        return sb.toString();
    }

    /**
     * Convert the given object to string with each line indented by 4 spaces (except the first line).
     */
    private String toIndentedString(java.lang.Object o) {
        if (o == null) {
            return "null";
        }
        return o.toString().replace("\n", "\n    ");
    }

}
